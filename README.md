# 1. 강좌 소개

- 시작일 250407

## 강의 목표

- JPA 내부 동작 방식 이해
- JPA 가 생성하는 SQL에 대해 이해
- JPA 가 언제 SQL을 실행하는지에 이해

# 2. JPA 소개

## SQL 중심적인 개발의 문제점

- 어플리케이션은 객체지향
- 데이터베이스는 관계형
- 객체를 관계형 DB에 관리하는 시대

- 객체에 필드 추가 변경시, 모든 쿼리를 변경해야 함
- 관계형 DB를 사용하는 이상 SQL에 의존적인 개발을 할 수 밖에 없다

### 객체와 RDBS의 차이

- 상속의 개념이 없다.
  - 모델링 기법인 **슈퍼타입 및 서브타입 도출 -** https://kkjsw17.tistory.com/12
- 연관관계
  - 객체는 참조
  - 테이블은 외래키
- 객체는 참조로 탐색가능(객체 그래프)
  - DAO 쿼리를 확인 해야 한다.
- 객체답게 모델링을 하면 매핑작업이 늘어난다.

### 객체를 컬렉션에 저장하듯 DB에 저장하는 ORM

## JPA 소개

- ORM: object relational mapping 객체 관계 매핑
- 객체는 객체대로설계
- DB는 DB대로 설계
- ORM 프레임워크가 중간에서 매핑

- JPA는 APP과 JDBC API 사이에서 동작
- EJB - entity bean(자바 표준)
- 개빈킹의 hibernate 오픈
- JPA(자바 표준) extends hibernate

## JPA는 표준 명세

- 표준명세 = 인터페이스의 모음
- JPA 2.1 표준명세를 구현한 3가지 구현체
- 하이버네이트(90%이상), 이클립스링크, 데이타누클리스

## JPA를 왜 사용해야하는가

- SQL 중심개발에서 객체중심개발
- 생산성, 유지보수, 성능
- 패러다임 불일치 해결
- 표준

값 변경하고 save하지말고 set 메서드만 실행해도 그게 db에 반영이 된다고??

이것이 **변경 감지(Dirty Checking) ㄷㄷ**

## ✅ 트랜잭션의 생명주기 (Spring 기준)

### 🔁 기본 흐름:

1. `@Transactional` 메서드 호출 (프록시가 감지)
2. 트랜잭션 시작 (`begin transaction`)
3. 메서드 실행
4. 메서드가 정상 종료 → `commit`
5. 예외 발생 시 → `rollback`

## 트랜잭션이 끝나는 시점은?

> ✅ @Transactional 메서드의 실행이 끝나고, Spring이 commit 또는 rollback을 수행할 때입니다.

## 패러다임 불일치 해결

1. JPA와 상속
2. 연관관계
3. 객체 그래프 탐색
4. 비교하기

## JPA 성능 최적화 기능

- 1차 캐시와 동일성 보장 - 같은 트랜잭션 안에서만
- 트랜직션 지원하는 지연 쓰기 - 배치 SQL 처리
- 지연 로딩
  - 연관된 엔티티를 참조할때 조회
- 즉시 로딩
  - 연관된 엔티티 전부 조회

와 매핑된 엔티티도 한번에 조회가 되는구나!!!

조인쿼리 날린다고 queryDsl 써봤는데…

### ORM은 객체와 RDB 두 기둥위에 있는 기술

# 3. JPA 시작하기

## project 생성

- 사용할 스프링 부트 버전의 doc을 보고 적절한 버전 사용

## 어플리케이션 개발

- 방언: SQL표준이 아닌 특정 DB의 고유기능

- data를 변경하는 모든작업은 트랜잭션안에서 실행해야한다.

### spring 프로젝트를 세팅했는데 member 저장이 안됌

- Spring에서 주입받는 EntityManager는 **스프링이 관리하는 Proxy(EntityManager)**
- 그래서 직접 트랜잭션을 수동으로 제어하면 안된다 함
- `@Transactional` 사용하니 됌

#### ✅ 중요 포인트 요약

| 잘못된 방식 (순수 JPA 스타일)                 | 올바른 Spring 방식                 |
| --------------------------------------------- | ---------------------------------- |
| `EntityTransaction tx = em.getTransaction()`  | `@Transactional`으로 트랜잭션 관리 |
| `tx.begin()`, `tx.commit()` 수동 호출         | 생략하고 `@Transactional`에 맡김   |
| `Persistence.createEntityManagerFactory(...)` | `@PersistenceContext`로 주입받음   |

---

#### 💡 왜 Spring에서 직접 트랜잭션을 못 여는가?

- `SharedEntityManager`는 **ThreadLocal 기반**의 Proxy입니다.
- 이 EntityManager는 스프링이 **트랜잭션 범위 내에서 자동으로 열고 닫아줍니다**.
- 사용자가 직접 `tx.begin()` 등을 호출하면 **컨텍스트 밖에서 트랜잭션을 제어하려는 시도**가 되어 예외가 발생합니다.

---

#### 🛠 추가 개선 팁

- `@Transactional`은 클래스 레벨 또는 메서드 레벨에서 붙일 수 있어요.
- 단, **`CommandLineRunner`에서 사용할 땐 반드시 `run()` 메서드에 붙여야 정상 동작**합니다.

### 📦 정리

```java
@Component
public class JpaRunner implements CommandLineRunner {

  @PersistenceContext
  private EntityManager em;

  @Override
  @Transactional
  public void run(String... args) throws Exception {
    System.out.println("JpaRunner START!!!!!");
    Member member = new Member();

    member.setId(1L);
    member.setName("hello");

    em.persist(member);

    System.out.println("JpaRunner END!!!!!");
  }
}
```

### 수정

이건 진짜 대박이다...

```java
Member member = em.find(Member.class, 1L);
member.setName("hello JPA");
```

### 주의

- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 엔티티 매니저는 쓰레드간에 공유X (사용하고 버려야 한다).
- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행
- DB는 다 트랜잭션 개념을 가지고 있다

### JPQL 소개

- 가장 단순한 조회 방법
- EntityManager.find()
- 객체 그래프 탐색(a.getB().getC())
- 나이가 18살 이상인 회원을 모두 검색하고 싶다면?

- 내가 원하면 데이터를 최적화해서 가져와야하고, 통계성 쿼리도 날려야함
- 기승전 쿼리

```java
// 가져오는 대상이 테이블이 아니고 객체
List<Member> members = em.createQuery("select m from Member m", Member.class).getResultList();
```

- paging을 지원하는데, DB에 맞게 SQL 생성

### JPQL이 필요한 이유

- JPA를 사용하면 엔티티 객체를 중심으로 개발
- 문제는 검색 쿼리
- 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
- 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능
- 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 **검색 조건이 포함된 SQL이 필요**

### JPQL

- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
- SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원
- JPQL은 엔티티 객체를 대상으로 쿼리
- SQL은 데이터베이스 테이블을 대상으로 쿼리
- 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존X
- JPQL을 한마디로 정의하면 객체 지향 SQL

# 4. 영속성 관리 - 내부 동작 방식

## 영속성 컨텍스트 1

### JPA에서 가장 중요한 2가지

- Object와 RDB 매핑 ORM
  - DB와 객체가 잘 연동 될 수 있게 설계
- 영속성 컨텍스트(persistance context)

  - JPA가 내부적으로 동작하는 방식

- 엔티티매니저팩토리와 엔티티매니저
- 엔티티매니저팩토리는 요청을 받으면 엔티티 매니저를 생성
- 엔티티매니저는 DB 커넥션을 사용함

- 영속성 컨텍스트: 엔티티를 영구저장하는 환경

  - persist 메서드는 영속성 컨텍스트에 저장한다는 의미

- 엔티티 라이프사이클

  - 비영속: 영속성 컨텍스트와 관계없음
  - 영속: 영속성 컨텍스트에 저장되어 관리되는 상태 // persist
  - 준영속: 영속성 컨텍스트에서 분리된 상태 // detech
  - 삭제: 영속성 컨텍스트에서 삭제 // remove

- 객체가 영속상태가 된다고해서 바로 DB에 쿼리에 날라가는게 아니라, 트랜잭션을 커밋하는 시점

### 영속성 컨텍스트의 이점

- 1차 캐시
- 동일성 보장
- 트랜잭션을 보장하는 쓰기지연
- 변경 감지(dirty checking)
- 지연 로딩(lazy loading)

## 영속성 컨텍스트 2

### 엔티티 조회, 1차 캐시

- 조회할때, 컨텍스트부터 확인해서 있다면 DB까지 가지않는다
  - react-query랑 굉장히 유사
- 1차 캐시는 하나의 트랜잭션에서만 유효하다.

  - 다른 요청으로 인한 트랜잭션과 같은 캐시를 공유하지 않는다는 의미
  - JPA에서 어플리케이션 전체에서 공유하는 캐시는 2차 캐시
  - 그렇기에 유의미한 성능이점은 없다.

- 데이터를 매번 DB에서 읽지 않고, 애플리케이션이 메모리에 보관해두고 사용하는 방식(1차 캐시)을 통해,
- 트랜잭션 동안 같은 데이터를 반복해서 읽어도 값이 변하지 않도록 보장하는 것. 이걸 DB 설정 없이 애플리케이션 내부에서 구현한 것이다."
  - 트랜잭션 격리 수준:REPEATABLE READ
    - 트랜잭션 격리 = DB에서 동시에 여러 작업이 일어날 때, 데이터의 일관성을 유지하기 위해 격리 수준을 설정
    - REPEATABLE READ = "트랜잭션 내에서 동일한 데이터를 여러 번 읽어도 값이 변하지 않도록 보장"하는 등급

### 엔티티 등록 - 쓰기 지연

- JPA에서는 데이터 변경이 반드시 트랜잭션 안에서 이루어져야 하며, 엔티티 매니저는 변경 내용을 즉시 DB에 반영하지 않는다.
- 트랜잭션 커밋 직전에 flush()를 통해 SQL을 한꺼번에 전송한다.
- Hibernate는 이 과정에서 JDBC Batch 기능을 활용해 SQL들을 버퍼에 모았다가, 여러 쿼리를 한 번에 처리할 수 있어 성능을 최적화한다.

- JPA는 객체를 만들 때 리플렉션(Reflection)을 사용하기 때문에, 반드시 기본 생성자(파라미터 없는 생성자)가 필요하다.

  - 내부적으로 리플렉션을 통해 객체를 만들고 필드에 값을 채움
  - 이때 리플렉션은 기본 생성자가 있어야만 객체를 생성

- JPA의 목적은 컬렉션을 사용하는 것처럼 객체를 다루는 것

  - 컬렉션에서 데이터를 변경했다면, 변경이 되어야 함

- 커밋을 하면 내부적으로 flush가 호출 됨
- 1차 캐시에는 엔티티와, 스냅샷(최초로 1차캐시에 들어온 시점의 데이터)
- 값을 전부 비교

- 리플렉션: 런타임에 클래스, 메서드, 필드 등 객체의 구조를 조사하고 조작

  - 기능
    - 클래스 이름, 필드 목록, 메서드 목록을 런타임에 조회
    - 접근 제한(private 등)을 무시하고 필드나 메서드에 접근
    - 객체의 클래스 타입을 모르더라도 동적으로 인스턴스를 생성
  - 기본 흐름:
    1. 클래스 로딩
    2. Class 객체 생성
    3. 리플렉션 API로 필드/메서드/생성자 조사
    4. 필요하면 setAccessible(true)로 private 접근 무시
    5. 값을 읽거나 설정하거나, 인스턴스를 생성
  - 단점
    - 성능 저하 - 리플렉션은 일반 코드보다 느림 (최적화 어려움)
    - 타입 안정성 낮음 - 컴파일 타임에 타입 체크가 안 됨 (런타임 오류 가능)
    - 유지보수 어려움 - 코드 흐름 추적이 어려움, 리팩토링 어려움
  - 일반 로직에서는 잘 안 쓰고, 프레임워크나 라이브러리 수준에서 주로 사용

## 플러시

- 영속성 컨텍스트의 변경내용을 DB에 반영하는 것
  - 영속성 컨텍스트를 비우는 것이 아님
- 트랜잭션이라는 작업단위가 중요하다 - 커밋직전에만 동기화하면 됨

### 플러시 발생

- 변경 감지
- 엔티티 수정
  - (쓰기 지연 SQL 저장소에 등록)
- SQL 저장소의 쿼리를 DB에 전송

### 영속성 컨텍스트를 플러시 하는 법

- em.flush() - 직접 호출
- tx.commit() - 자동 호출
- JPQL query - 자동 호출

### flush mode

- auto: commit or query 실행 시 flush(기본)
- commit: commit만 flush

## 준영속 상태

- 영속상태의 엔티티를 영속성 컨텍스트에서 분리

### 준영속상태로 만드는 법

- em.detach(): 특정 엔티티만
- em.clear(): 컨텍스트 초기화
- em.close(): 컨텍스트 종료
